{% load static %}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">

    <!-- Load favicon -->
    <link rel="shortcut icon" type="image/png" href="{% static 'img/favicon.ico' %}" />

    <!-- Include your CSS files here -->
    <link rel="preload" as="style" href="{% static 'css/style.css' %}" onload="this.rel = 'stylesheet'" />
    <link rel="stylesheet" href="https://justingolden.me/pokemon-types-css/types.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PokeGrids</title>
</head>

<body>
    <header>
        <div class="container">
            <!-- Title -->
            <h1>PokeGrid</h1>
            <nav>
            <!-- Nav Bar -->
                <ul>
                    <li><a href="#">Home</a></li>
                    <li><a href="#">Twitter</a></li>
                    <li><a href="#">Help</a></li>
                    <!-- Add more links as needed -->
                </ul>
            </nav>
        </div>
    </header>

    <main>
        <!-- Search Modal -->
        <div class="modal" id="search-modal">
            <div class="modal-content">
                <div>
                    <input placeholder="Search pokemon..." autocomplete="off" autocorrect="off" spellcheck="false" type="search" id="search-input">
                    <!-- Dropdown list for Pokemon names -->
                    <div id="pokemon-list" style="max-height: 175px; overflow-y: auto; border: 1px solid #ccc; border-radius: 5px; display: none;">
                    </div>
                </div>
            </div>
        </div>

        <!-- PostGameModal Modal -->
        <div class="modal" id="postGameModal">
            <div class="post-modal-content">
                <span class="close" onclick="closePostGameModal()">&times;</span>
                <h2>Post-Game Statistics</h2>
                <h3>Most Submited Per Grid</h3>
                <div id="smallerGridContainer">
                    <div class="most-submitted grid0"></div>
                    <div class="most-submitted grid1"></div>
                    <div class="most-submitted grid2"></div>
                    <div class="most-submitted grid3"></div>
                    <div class="most-submitted grid4"></div>
                    <div class="most-submitted grid5"></div>
                    <div class="most-submitted grid6"></div>
                    <div class="most-submitted grid7"></div>
                    <div class="most-submitted grid8"></div>
                </div>
                <!-- Add any other information you want to display -->
            </div>
        </div>

        <div class="app">
            <div class="top">
                <div class="col-characteristic" id="score-heading" >Score: <div id="total-score">0.00</div></div>
                <!-- Placeable pictures or words for characteristics -->
                {% for item in grid_data|slice:":3" %}
                    {% if item.selected == 1 %}
                        <div class="col-characteristic selector1" id="trait-col{{forloop.counter}}">
                        {% if item.type == "Mono" %}
                            <span class="typing Mono" style="border-radius: 4px;">Mono Type</span>
                        {% elif item.type == "Dual" %}
                            <span class="typing Dual" style="border-radius: 4px;">Dual Type</span>
                        {% else %}
                            <span class="type {{item.type}}" style="border-radius: 4px;"></span>
                        {% endif %}
                        </div>
                    {% elif item.selected == 2 %}
                        <div class="col-characteristic selector2" id="trait-col{{forloop.counter}}">Gen {{item.generation}}</div>
                    {% elif item.selected == 3 %}
                        <div class="col-characteristic selector3" id="trait-col{{forloop.counter}}">Stage {{item.evolution_stage}}</div>
                    {% elif item.selected == 4 %}
                        <div class="col-characteristic selector4" id="trait-col{{forloop.counter}}">Legendary</div>    
                    {% endif %}
                {% endfor %}
            </div>
            <div class="container">
                <div class="characteristics">
                <!-- Placeable pictures or words for characteristics -->
                {% for item in grid_data|slice:"3:" %}
                    {% if item.selected == 1 %}
                        <div class="row-characteristic selector1" id="trait-row{{forloop.counter}}">
                            {% if item.type == "Mono" %}
                                <span class="typing Mono">Mono Type</span>
                            {% elif item.type == "Dual" %}
                                <span class="typing Dual">Dual Type</span>
                            {% else %}
                                <span class="type {{item.type}}" style="border-radius: 4px;"></span>
                            {% endif %}
                        </div>
                    {% elif item.selected == 2 %}
                        <div class="row-characteristic selector2" id="trait-row{{forloop.counter}}">Gen {{item.generation}}</div>
                    {% elif item.selected == 3 %}
                        <div class="row-characteristic selector3" id="trait-row{{forloop.counter}}">Stage {{item.evolution_stage}}</div>
                    {% elif item.selected == 4 %}
                        <div class="row-characteristic selector4" id="trait-row{{forloop.counter}}">Legendary</div>    
                    {% endif %}
                {% endfor %}
                </div>
                <div class="grid-container" id="grid-container">
                    <!-- 3x3 grid -->
                    <div class="grid-item row1 col1" onclick="handleClick(this, event)"></div>
                    <div class="grid-item row1 col2" onclick="handleClick(this, event)"></div>
                    <div class="grid-item row1 col3" onclick="handleClick(this, event)"></div>
                    <div class="grid-item row2 col1" onclick="handleClick(this, event)"></div>
                    <div class="grid-item row2 col2" onclick="handleClick(this, event)"></div>
                    <div class="grid-item row2 col3" onclick="handleClick(this, event)"></div>
                    <div class="grid-item row3 col1" onclick="handleClick(this, event)"></div>
                    <div class="grid-item row3 col2" onclick="handleClick(this, event)"></div>
                    <div class="grid-item row3 col3" onclick="handleClick(this, event)"></div>
                </div>
            </div>
            <button id="clear-grid-button" onclick="clearGrid()">Clear Grid</button>
            <button id="open-postGameModal" onclick="openPostGameModal()">Show Statistics</button>
        </div>
       
    </main>

    <footer>
    </footer>

    <script>
        
        var selectedPokemon = [];
        var totalScore = 0;
        const date = getFormattedDate();

        // Define a debounce function
        function debounce(func, delay) {
            let timeoutId;
            return function () {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(func, delay);
            };
        }

        // Function to open the search modal
        function handleClick(gridItem) {
            // Remove the 'selected' class from any previously selected grid item
            var selectedGridItem = document.querySelector('.grid-item.selected');
            if (selectedGridItem) {
                selectedGridItem.classList.remove('selected');
            }

            // Add the 'selected' class to the current grid item
            gridItem.classList.add('selected');

            // Show the search modal
            document.getElementById('search-modal').style.display = 'block';

            // Select the input and reset its value
            var input = document.querySelector('#search-modal input');
            input.select();
            input.value = '';

            // Add debounced event listener for input changes
            input.addEventListener('input', debounce(fetchPokemonNames, 300));
        }

        // Function to close the search modal
        function closeSearchModal() {
            var modal = document.getElementById('search-modal');
            var pokemonList = document.getElementById('pokemon-list');
            
            // Clear the dropdown and hide it
            pokemonList.innerHTML = '';
            pokemonList.style.display = 'none';

            // Remove input event listener
            var input = document.querySelector('#search-modal input');
            input.removeEventListener('input', debounce(fetchPokemonNames, 300));

            // Hide the modal
            modal.style.display = 'none';
        }

        // Function to fetch Pokemon names and populate the dropdown
        function fetchPokemonNames() {
            // Cancel any existing fetch request
            if (window.abortController) {
                window.abortController.abort();
            }

            // Create a new AbortController
            window.abortController = new AbortController();

            var pokemonList = document.getElementById('pokemon-list');
            var searchInput = document.getElementById('search-input').value;

            // Create a URLSearchParams object to include the search parameter
            var params = new URLSearchParams();
            params.set('search', searchInput);

            // Fetch Pokemon names from Django backend
            fetch('/api/pokemon/?' + params, { signal: window.abortController.signal })
                .then(response => response.json())
                .then(data => {
                    // Clear existing dropdown items
                    pokemonList.innerHTML = '';

                    // Populate the dropdown with Pokemon names and Select buttons
                    data.results.forEach(pokemon => {
                        if (!selectedPokemon.includes(pokemon.name)) {
                            var option = document.createElement('div');
                            option.style.display = 'flex';
                            option.style.alignItems = 'center';

                            var pokemonImage = document.createElement('img');
                            pokemonImage.className = 'pokemon-dropdown-image';

                            // Check if the image with the specified Pokédex number exists
                            doesImageExist(pokemon.pokedex_number, function (exists) {
                                // Update the image source based on whether it exists or not
                                pokemonImage.src = exists
                                    ? `{% static 'img/pokemon/main-sprites/' %}${pokemon.pokedex_number}.png`
                                    : `{% static 'img/pokemon/main-sprites/0.png' %}`;
                            });

                            var nameSpan = document.createElement('span');
                            nameSpan.textContent = pokemon.name;

                            var selectButton = document.createElement('button');
                            selectButton.textContent = 'Select';

                            // Set up an event listener to handle click on the "Select" button
                            selectButton.addEventListener('click', function () {
                                handleSelect(pokemon);
                            });

                            // Append the image, name, and "Select" button to the dropdown
                            option.appendChild(pokemonImage);
                            option.appendChild(nameSpan);
                            option.appendChild(selectButton);

                            // Append the option to the dropdown
                            pokemonList.appendChild(option);
                        }
                    });

                    // Show the dropdown
                    pokemonList.style.display = 'block';
                })
                .catch(error => {
                    if (error.name !== 'AbortError') {
                        console.error('Error fetching Pokemon names:', error);
                    }
                });
        }

        function doesImageExist(pokedexNumber, callback) {
            var img = new Image();
            img.onload = function () {
                callback(true);
            };
            img.onerror = function () {
                callback(false);
            };
            img.src = `{% static 'img/pokemon/main-sprites/' %}${pokedexNumber}.png`;
        }

    
        // Handle clicks outside the modal to close it
        window.onclick = function(event) {
            var modal = document.getElementById('search-modal');
            if (event.target == modal) {
                closeSearchModal();
                closePostGameModal();
            }
        };

        // Check trait of pokemon to selected trait
        function checkTrait(pokemon, trait, traitText, selector) {
            switch (`${selector}`) {
                case 'selector1':
                    var typingSpan = trait.querySelector('.typing');
                        if (typingSpan && typingSpan.textContent == "Mono Type") {
                            return pokemon.type2.trim() === '';
                        } else if (typingSpan && typingSpan.textContent == "Dual Type") {
                            return !(pokemon.type2.trim() === '');
                        }
                    var typeSpan = trait.querySelector('.type');
                    return typeSpan && (typeSpan.classList.contains(pokemon.type1.toLowerCase()) || typeSpan.classList.contains(pokemon.type2.toLowerCase()));
                case 'selector2':
                    var traitGeneration = parseInt(traitText.match(/\d+/)[0], 10);
                    return pokemon.generation === traitGeneration;
                case 'selector3':
                    var traitStage = parseInt(traitText.match(/\d+/)[0], 10);
                    return pokemon.evolution_stage === traitStage;
                case 'selector4':
                    return pokemon.legendary !== "Normal";
                default:
                    return false;
            }
        }
        function handleSelect(pokemon) {
            var selectedGridItem = document.querySelector('.grid-item.selected');
            
            if (selectedGridItem) {

                // Check if a Pokemon is already selected for this grid
                if (selectedPokemon.includes(pokemon.name)) {
                    alert("Pokemon already selected for this grid!");
                    return;
                }

                // Get the row and col classes from the selectedGridItem
                var rowClass = [...selectedGridItem.classList].find(className => className.startsWith('row'));
                var colClass = [...selectedGridItem.classList].find(className => className.startsWith('col'));

                // Get the corresponding row and col traits
                var rowTrait = document.querySelector(`#${rowClass.replace('row', 'trait-row')}`);
                var colTrait = document.querySelector(`#${colClass.replace('col', 'trait-col')}`);

                var rowTraitText = rowTrait.textContent
                var colTraitText = colTrait.textContent

                 // Get the row and col values without the prefixes
                var rowValue = parseInt(rowClass.replace("row", ""), 10);
                var colValue = parseInt(colClass.replace("col", ""), 10);

                // Check the class selectors of rowTrait and colTrait
                var rowSelector = [...rowTrait.classList].find(className => className.startsWith('selector'));
                var colSelector = [...colTrait.classList].find(className => className.startsWith('selector'));

                var rowCheck = checkTrait(pokemon, rowTrait, rowTraitText, rowSelector);
                var colCheck = checkTrait(pokemon, colTrait, colTraitText, colSelector);

                if (rowCheck && colCheck) {
                    if (selectedGridItem.textContent) {
                        // Remove the corresponding Pokémon name from the selectedPokemon array
                        var previousPokemonName = selectedGridItem.querySelector('.pokemon-name').textContent;
                        removePokemonName(selectedGridItem, previousPokemonName);
                    }
                    // Update the selected Pokemon and prevent it from being selected again
                    selectedPokemon.push(pokemon.name);

                    // Calculate the percentage for the selected Pokemon in this grid
                    var gridIndex = getGridIndex(rowValue, colValue)
                    getTotalSubmissionsInGrid()
                    .then(totalSubmissions => {
                        return getPokemonStatisticCount(gridIndex, pokemon.name)
                            .then(selectedPokemonCount => {

                                var percentage = (selectedPokemonCount / totalSubmissions) * 100;

                                updateScore(percentage);

                                // Update the grid item with the Pokemon name and percentage
                                var percentageElement = document.createElement('div');
                                percentageElement.className = 'percentage';
                                percentageElement.textContent = `${percentage.toFixed(2)}%`;

                                var pokemonImageElement = document.createElement('img');
                                pokemonImageElement.className = 'pokemon-image'; 
                                doesImageExist(pokemon.pokedex_number, function (exists) {
                                    // Update the image source based on whether it exists or not
                                    pokemonImageElement.src = exists
                                        ? `{% static 'img/pokemon/main-sprites/' %}${pokemon.pokedex_number}.png`
                                        : `{% static 'img/pokemon/main-sprites/0.png' %}`;
                                });

                                var pokemonNameElement = document.createElement('div');
                                pokemonNameElement.className = 'pokemon-name';
                                pokemonNameElement.textContent = pokemon.name;

                                // Clear existing content and append the new elements
                                selectedGridItem.innerHTML = '';
                                selectedGridItem.appendChild(percentageElement);
                                selectedGridItem.appendChild(pokemonImageElement);
                                selectedGridItem.appendChild(pokemonNameElement);

                                 //Check to see if the grid is completed and send a submission if full
                                if (selectedPokemon.length === 9) {
                                     // Call the combined function
                                     setTimeout(() => {
                                        submitScoreAndGetAverageScore()
                                            .then(() => console.log('All operations completed'))
                                            .catch(error => console.error(error));
                                        submitGrid();
                                    },1);
                                }
                            });
                        })
                        .catch(error => {
                            console.error('Error:', error);
                            // Handle the error as needed
                    });
                }
            }
            closeSearchModal();
        }
        
        function removePokemonName(selectedGridItem, previousPokemonName) {
            // Remove the corresponding Pokémon name from the selectedPokemon array
            var indexToRemove = selectedPokemon.indexOf(previousPokemonName);
            if (indexToRemove !== -1) {
                selectedPokemon.splice(indexToRemove, 1);
            }
        }

        function submitScoreAndGetAverageScore() {
            return new Promise((resolve, reject) => {
                submitScore(totalScore)
                    .then(() => {
                        console.log('submitScore completed');
                        return getAverageScore();
                    })
                    .then(() => {
                        console.log('getAverageScore completed');
                        resolve();
                    })
                    .catch(error => {
                        console.error('Error in ScoreAndGetAverage:', error);
                        reject(error);
                    });
            });
        }

        function updateScore(percentage) {
            totalScore += percentage
            // Update the UI to display the total score
            var totalScoreElement = document.getElementById('total-score');
            if (totalScoreElement) {
                totalScoreElement.textContent = `${totalScore.toFixed(2)}`;
            }

   
        }

        function getGridIndex(row, col) {
            return (row - 1) * 3 + (col - 1)
        }

        function getTotalSubmissionsInGrid() {
            return fetch(`/api/submission-count/${date}/`)
                .then(response => response.json())
                .then(data => {
                    if ('count' in data) {
                        if (data.count !== 0){
                            return data.count/9;
                        } else {
                            return 1;
                        }
                    } else {
                        throw new Error('Failed to get submission count');
                    }
                })
                .catch(error => {
                    console.error('Error fetching submission count:', error);
                    return 0; // Return a default value or handle the error as needed
                });
        }

        function getPokemonStatisticCount(grid, pokemonName) {
            return fetch(`api/pokemon-statistic/${grid}/${pokemonName}/${date}/`)
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    } else if (response.status === 500) {
                        // PokemonStatistic not found, return 0
                        return { count: 0 };
                    } else {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                })
                .then(data => {
                    if ('count' in data) {
                        return data.count;
                    } else {
                        throw new Error('Failed to get submission count for the PokemonStatistic');
                    }
                })
                .catch(error => {
                    console.error('Error fetching submission count for the PokemonStatistic:', error);
                    return 0; // Return a default value or handle the error as needed
                });
        }

        // Function to handle the submission process
        function submitGrid() {
            console.log('Inside submitGrid');
            alert("Submitting the grid!");
            closeSearchModal();
            var gridIndex = 0;
            for (let row = 1; row <= 3; row++) {
                for (let col = 1; col <= 3; col++) {
                // Get the selected Pokemon name from the grid item
                sendPayload(gridIndex, row, col);
                gridIndex++;
                }
            }
            fetchPostGameStatistics();
            
        }

        function submitScore(score) {
            console.log('Inside submitScore');
            return new Promise((resolve, reject) => {
                var scoreAsFloat = parseFloat(score);
                var payload = {
                    score: score,
                    date: date,
                };

                fetch('/api/score/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken'), 
                    },
                    body: JSON.stringify(payload),
                })
                .then(response => {
                    console.log('Response status:', response.status);  // Log the response status
                    if (response.ok) {
                        return response.json();
                    } else {
                        throw new Error('Score submission failed');
                    }
                })
                .then(data => {
                    console.log('Score submission successful:', data);
                    resolve();  // Resolve the promise
                })
                .catch(error => {
                    console.error('Error submitting score:', error);
                    reject(error);  // Reject the promise with an error
                });
            });
        }

        function getAverageScore(){
            // Make a GET request to the scores endpoint
            fetch('/api/score/')
                .then(response => {
                // Check if the request was successful (status code 2xx)
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json(); // Parse the response JSON
                })
                .then(scores => {
                // Filter scores for the current day (you may need to adjust the date comparison)
                const scoresForDay = scores.filter(score => score.date === date);

                // Calculate the average score
                if (scoresForDay.length > 0) {
                    // Sort scores in descending order
                    const sortedScores = scoresForDay.map(score => score.score).sort((a, b) => b - a);
                    console.log(sortedScores);
                    // Find the index of the current score in the sorted array
                    const rank = sortedScores.indexOf(totalScore);
                    // Calculate the percentile
                    const percentile = ((rank) / (sortedScores.length)) * 100;

                    // Log or use the percentile as needed
                    console.log(`Current Score is at the ${percentile.toFixed(2)}th percentile`);
                    appendPercentileToModal(percentile);
                } else {
                    console.log(`No scores available for ${date}`);
                }
                })
                .catch(error => {
                // Handle errors (e.g., network issues, server errors)
                console.error('Error fetching scores:', error);
                });
            }

                    


        function sendPayload(gridIndex, row, col) {
            const gridItem = document.querySelector(`.grid-item.row${row}.col${col}`);
            if (gridItem) { 
                const pokemonNameElement = gridItem.querySelector('.pokemon-name');
                const pokemonName = pokemonNameElement ? pokemonNameElement.textContent : null;

                if (pokemonName) {
                    const payload = {
                        grid: gridIndex,
                        date: date,
                        pokemon: pokemonName,
                    };
                    fetch('/api/submission/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken'),
                        },
                        body: JSON.stringify(payload),
                    })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP error! Status: ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            console.log('Submission successful:', data);
                        })
                        .catch(error => {
                            console.error('Error submitting grid:', error);
                        });
                }
            }
        }


        function getFormattedDate() {
            const currentDate = new Date();
            const utcDate = new Date(Date.UTC(
                currentDate.getUTCFullYear(),
                currentDate.getUTCMonth(),
                currentDate.getUTCDate()
            ));
            return `${utcDate.getUTCFullYear()}-${(utcDate.getUTCMonth() + 1).toString().padStart(2, '0')}-${utcDate.getUTCDate().toString().padStart(2, '0')}`;
        }

        function clearGrid() {
            var selectedGridItem = document.querySelector('.grid-item.selected');
            if (selectedGridItem) {
                selectedGridItem.classList.remove('selected');
            }

            var gridItems = document.querySelectorAll('.grid-item');
            gridItems.forEach(item => {
                item.innerHTML = '';
            });

            selectedPokemon = [];
            var score = document.getElementById('total-score');
            score.innerHTML= '0.00';
            totalScore = 0;
            closeSearchModal();
        }


        // Function to get CSRF token from cookie
        function getCookie(name) {
            var cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                var cookies = document.cookie.split(';');
                for (var i = 0; i < cookies.length; i++) {
                    var cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        function openPostGameModal() {
            var postGameModal = document.getElementById('postGameModal');
            if (postGameModal) {
                postGameModal.style.display = 'block';
            }
        }

        function closePostGameModal() {
            var postGameModal = document.getElementById('postGameModal');
            if (postGameModal) {
                postGameModal.style.display = 'none';
            }
        }

        function fetchPostGameStatistics() {
            for (var i = 0; i < 9; i++){
                fetchMostSubmittedPokemon(i);
            }
            openPostGameModal();
        }

        function fetchMostSubmittedPokemon(grid){
            console.log(grid);
            console.log(date);
            fetch(`/api/pokemon-statistic/${grid}/${date}/`)
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    } else {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                })
                .then(data => {
                    // Update the modal content with the fetched data
                    updatePostGameModalContent(grid, data);
                })
                .catch(error => {
                    console.error('Error fetching most submitted Pokemon:', error);
                    // Handle the error as needed
                });
        }

        function updatePostGameModalContent(grid, data) {
        var mostSubmittedItem = document.querySelector(`.most-submitted.grid${data.grid}`);
        
        if (mostSubmittedItem) {
            getTotalSubmissionsInGrid()
            .then(totalSubmissions => {
                var percentage = (data.submission_count / totalSubmissions) * 100
                var percentageElement = document.createElement('div');
                percentageElement.className = 'percentage';
                percentageElement.textContent = `${percentage.toFixed(2)}%`;

                var pokemonImageElement = document.createElement('img');
                pokemonImageElement.className = 'pokemon-image';

                var pokedexNumber = data.pokemon.pokedex_number;

                doesImageExist(pokedexNumber, function (exists) {
                    // Update the image source based on whether it exists or not
                    pokemonImageElement.src = exists
                        ? `{% static 'img/pokemon/main-sprites/' %}${pokedexNumber}.png`
                        : `{% static 'img/pokemon/main-sprites/0.png' %}`;
                });

                var pokemonNameElement = document.createElement('div');
                pokemonNameElement.className = 'pokemon-name';
                pokemonNameElement.textContent = data.pokemon.name;

                // Clear existing content and append the new elements
                mostSubmittedItem.innerHTML = '';
                mostSubmittedItem.appendChild(percentageElement);
                mostSubmittedItem.appendChild(pokemonImageElement);
                mostSubmittedItem.appendChild(pokemonNameElement);
            })
        }
    }

        function appendPercentileToModal(percentile) {
            // Append percentile to the postGameModal
            var postGameModal = document.getElementById('postGameModal');
            if (postGameModal) {
                var percentileElement = document.createElement('div');
                percentileElement.textContent = `Your submission was in the ${percentile.toFixed(2)}th percentile!`;

                // Append the percentile element after the h2 of the postGameModal
                postGameModal.querySelector('h2').insertAdjacentElement('afterend', percentileElement);
            }
        }
    
    </script>
    
</body>

</html>
